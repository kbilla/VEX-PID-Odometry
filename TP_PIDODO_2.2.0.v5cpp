{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor leftDrive = motor(PORT1, ratio18_1, false);\n\nmotor rightDrive = motor(PORT2, ratio18_1, true);\n\nencoder leftEncoder = encoder(Brain.ThreeWirePort.A);\nencoder rightEncoder = encoder(Brain.ThreeWirePort.C);\nencoder centerEncoder = encoder(Brain.ThreeWirePort.E);\npot autonSwitch = pot(Brain.ThreeWirePort.G);\nmotor hDrive = motor(PORT3, ratio18_1, false);\n\nmotor LeftLift = motor(PORT4, ratio18_1, false);\n\nmotor RightLift = motor(PORT5, ratio18_1, true);\n\nmotor Claw = motor(PORT6, ratio18_1, false);\n\nmotor Mogo = motor(PORT7, ratio18_1, false);\n\nmotor Intake = motor(PORT8, ratio18_1, false);\n\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*--------------------------------------------------------------------------------------------------*/\n/*                                                                                                  */\n/*    Module:       TP_test.v5cpp                                                                   */\n/*    Author:       {99371D Irish Wristwatch - Cory Yu, Shankar Kalidindi, and Kellan Billadeau}    */\n/*    Created:      {10/26/21}                                                                      */\n/*    Version:      {2.2.0}                                                                         */\n/*    Description:  Autonomous Code with PID and Odometry                                           */\n/*                                                                                                  */\n/*--------------------------------------------------------------------------------------------------*/\n\n/*-------------------------*/\n/*                         */\n/*    Library Settings     */\n/*                         */\n/*-------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Include the Math Library\n#include <cmath>\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Initializes competitive format\ncompetition Competition;\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*    PERIOD: Pre-Autonomous (preparation for autonomous period)    */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nvoid pre_auton(void){\n    // clearing encoders, setting servo positions\n    leftDrive.setPosition(0,degrees);\n    rightDrive.setPosition(0,degrees);\n    hDrive.setPosition(0,degrees);\n    leftDrive.setStopping(brake);\n    rightDrive.setStopping(brake);\n    hDrive.setStopping(brake);\n    Brain.Screen.clearScreen();\n}\n\n/*--------------------------------------------*/\n/*                                            */\n/*     Autonomous Variables and Constants     */\n/*                                            */\n/*--------------------------------------------*/\n\n/////////////////////////////////\n// PID Constants and Variables //\n/////////////////////////////////\n\n// constants\ndouble driveXKP = 1;\ndouble driveXKI = 1;\ndouble driveXKD = 1;\n\ndouble driveYKP = 1;\ndouble driveYKI = 1;\ndouble driveYKD = 1;\n\ndouble turnKP = 1;\ndouble turnKI = 1;\ndouble turnKD = 1;\n\ndouble liftKP = 1;\ndouble liftKI = 1;\ndouble liftKD = 1;\n\n// variables\ndouble currentXValue = 0;\ndouble desiredXValue = 0;\ndouble errorX = 0;\ndouble lastXError = 0; // position 20ms ago\ndouble totalXError = 0;\ndouble derivativeX;\n\ndouble currentYValue = 0;\ndouble desiredYValue = 0;\ndouble errorY = 0;\ndouble lastYError = 0; // position 20ms ago\ndouble totalYError = 0;\ndouble derivativeY;\n\ndouble currentTurnValue = 0;\ndouble desiredTurnValue = 0;\ndouble errorTurn = 0;\ndouble lastTurnError = 0; // position 20ms ago\ndouble totalTurnError = 0;\ndouble derivativeTurn;\n\ndouble currentLiftValue = 0;\ndouble desiredLiftValue = 0;\ndouble errorLift = 0;\ndouble lastLiftError = 0; // position 20ms ago\ndouble totalLiftError = 0;\ndouble derivativeLift;\n\n//////////////////////////////////////\n// ODOMETRY CONSTANTS and Variables //\n//////////////////////////////////////\n\n// constants\ndouble encWheelRadius = 3.25/2;\ndouble enDriveWidth = 10; // distance between encoders\ndouble cEncOffset = 5; // distance between midpoint of l, r, and point c. Forward offset is position, backward negative.\n\n// variables\ndouble l = 0;\ndouble r = 0;\ndouble c = 0;\ndouble prevL = 0;\ndouble prevR = 0;\ndouble prevC = 0;\n\ndouble odoXPos = 0;\ndouble odoYPos = 0;\ndouble odoAng = 0;\n\n/////////////////////\n// Movement Inputs //\n/////////////////////\n\ndouble x = 0;\ndouble y = 0;\ndouble theta = 0;\ndouble phi = 0;\n\n/////////////////\n// PID Outputs //\n/////////////////\n\ndouble driveXPIDOutput = 0;\ndouble driveYPIDOutput = 0;\ndouble turnPIDOutput = 0;\ndouble liftPIDOutput = 0;\n\n/*--------------------------*/\n/*                          */\n/*    Threads/Tasks         */\n/*                          */\n/*--------------------------*/\n\n// PID boolean (allows turning PID and Odometry on/off)\nbool enableDrivePIDODO = false;\n\n// PID control for drivetrain in X direction\nint drivePIDODO(){\n    while(enableDrivePIDODO){\n\n        ///////////////////////\n        // ODOMETRY FUNCTION //\n        ///////////////////////\n\n        // update encoder position, arclength of wheel circumference = radius of wheel * angle (radians)\n        l = encWheelRadius * (leftEncoder.position(degrees))*M_PI/180;\n        r = encWheelRadius * (rightEncoder.position(degrees))*M_PI/180;\n        c = encWheelRadius * (centerEncoder.position(degrees))*M_PI/180;\n\n        //update differential\n        double dL = l - prevL;\n        double dR = r - prevR;\n        double dC = c - prevC;\n\n        // update phi (if you look at the math, the change in heading, phi, ends up being equal to the theta created by the curve)\n        double phiOdo = (dL - dR)/enDriveWidth;\n\n        // update lateral vector\n        double dM = (dL + dR)/2;\n\n        // update horizontal vector\n        double dS = cEncOffset*phiOdo;\n\n        // update position differential\n        double dx;\n        double dy;\n\n        //conditional for phi = 0\n        if(phiOdo != 0){\n            dx = (dM / phiOdo)*sin(phiOdo)*tan(phiOdo/2) + dC*cos(phiOdo) - dS*cos(phiOdo);\n            dy = (dM / phiOdo)*sin(phiOdo) + dS*cos(phiOdo) - dC*sin(phiOdo) + dS*sin(phiOdo);\n        }\n        else{\n            dy = dM;\n            dx = dC;\n        }\n\n        Brain.Screen.clearScreen();\n        Brain.Screen.print(dx);\n        Brain.Screen.print(\", \");\n        Brain.Screen.print(dy);\n\n        // accumulate coordinate position and direction\n        odoXPos += dx;\n        odoYPos += dy;\n        odoAng += phiOdo;\n\n        // update previous encoder position\n        prevL = l;\n        prevR = r;\n        prevC = c;\n\n        ////////////////////\n        // X Movement PID //\n        ////////////////////\n\n        // update average X direction motor position\n        currentXValue = odoXPos;\n\n        // P - Proportional: Adjusts speed of motor to error, leaves \"offset\" (does not perfectly reach destination)...\n        // ... and \"noise\" (over/undershooting the destination, oscilates until reaching destination)\n        errorX = desiredXValue - currentXValue;\n\n        // I - Integral: Removes offset\n        totalXError = totalXError + errorX;\n\n        // D - Derivative: Removes noise\n        derivativeX = errorX - lastXError;\n\n        // OUTPUT: How fast the motors should move\n        driveXPIDOutput = (driveXKP * errorX) + (driveXKI * totalXError) + (driveXKD * derivativeX);\n\n        \n        ////////////////////\n        // Y Movement PID //\n        ////////////////////\n\n        // update Y direction motor position\n        currentYValue = odoYPos;        \n\n        // P - Proportional: Adjusts speed of motor to error, leaves \"offset\" (does not perfectly reach destination)...\n        // ... and \"noise\" (over/undershooting the destination, oscilates until reaching destination)\n        errorY = desiredYValue - currentYValue;\n\n        // I - Integral: Removes offset\n        totalYError = totalYError + errorY;\n\n        // D - Derivative: Removes noise\n        derivativeY = errorY - lastYError;\n\n        // OUTPUT: How fast the motors should move\n        driveYPIDOutput = (driveYKP * errorY) + (driveYKI * totalYError) + (driveYKD * derivativeY);\n\n\n        //////////////\n        // Turn PID //\n        //////////////\n\n        // update motor position during turn\n        currentTurnValue = odoAng;        \n\n        // P - Proportional: Adjusts speed of motor to error, leaves \"offset\" (does not perfectly reach destination)...\n        // ... and \"noise\" (over/undershooting the destination, oscilates until reaching destination)\n        errorTurn = desiredTurnValue - currentTurnValue;\n\n        // I - Integral: Removes offset\n        totalTurnError = totalTurnError + errorTurn;\n\n        // D - Derivative: Removes noise\n        derivativeTurn = errorTurn - lastTurnError;\n\n        // Output: How fast the motors should move\n        turnPIDOutput = (turnKP * errorTurn) + (turnKI * totalTurnError) + (turnKD * derivativeTurn); \n\n        //////////////\n        // Lift PID //\n        //////////////\n\n        // update motor position during lift\n        currentLiftValue = (LeftLift.position(degrees) + RightLift.position(degrees))/2;        \n\n        // P - Proportional: Adjusts speed of motor to error, leaves \"offset\" (does not perfectly reach destination)...\n        // ... and \"noise\" (over/undershooting the destination, oscilates until reaching destination)\n        errorLift = desiredLiftValue - currentLiftValue;\n\n        // I - Integral: Removes offset\n        totalLiftError = totalLiftError + errorLift\n\n        // D - Derivative: Removes noise\n        derivativeLift = errorLift - lastLiftError;\n\n        // Output: How fast the motors should move\n        liftPIDOutput = (liftKP * errorLift) + (liftKI * totalLiftError) + (liftKD * derivativeLift); \n\n        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        ///////////////////////\n        // Movement Commands //\n        ///////////////////////\n\n        leftDrive.spin(forward, driveYPIDOutput + turnPIDOutput, voltageUnits::volt);\n        rightDrive.spin(forward, driveYPIDOutput - turnPIDOutput, voltageUnits::volt);\n        hDrive.spin(forward, driveXPIDOutput, voltageUnits::volt);\n        LeftLift.spin(forward, liftPIDOutput, voltageUnits::volt);\n        RightLift.spin(forward, liftPIDOutput, voltage::volt);\n\n        vex::task::sleep(20); // Integral approximation dt = 20ms, also helps the brain cycle\n    }\n    return 1;\n}\n\n/*-----------------------*/\n/*                       */\n/*    Void Statements    */\n/*                       */\n/*-----------------------*/\n\n/////////////////////\n// Drive Modifiers //\n/////////////////////\n\n// Adjusted Coordinate Plane (ACP) Input Scheme - travells to input location no matter the heading\nvoid acp(double dx, double dy, double phiFinal){ // input desired x and y travel distances and current heading\n    \n    //Checks current angle to input phi\n    double phiCurrent = odoAng;\n\n    // check math book for adjusted graph calculations\n    double acpX = dx/cos(phiCurrent)+(dy-dx*tan(phiCurrent))*sin(phiCurrent);\n    double acpY = (dy-dx*tan(phiCurrent))*pow(sin(phiCurrent), 2.0);\n\n    //drives to (x, y) coordinate on new path\n    x = acpX;\n    y = acpY;\n}\n\nvoid curveDrive(double desXCurve, double desYCurve, double thetaFinal){\n\n    //////////////////\n    // TOTAL VALUES //\n    //////////////////\n\n    //total travelling/target values\n    double dhCurveTotal = sqrt(pow(desXCurve, 2) + pow(desYCurve, 2)); //diagonal made by dx and dy\n    double dMCurveTotal = dhCurveTotal*(thetaFinal*cos(thetaFinal/2)) / sin(thetaFinal); //curve around (0,r) contacting (0,0) and (dx,dy)\n    //length of dMCurveTotal is dictated by theta\n\n    double r = dMCurveTotal/thetaFinal; //radius, it's constant for the whole curve\n\n    //////////////////\n    // ERROR VALUES //\n    //////////////////\n\n    //create adjusting x, y values to allow the direction of the motion along the curve to continue changing\n    //valueFinal - valueCurrent = error\n    double xCurveError = desXCurve - odoXPos;\n    double yCurveError = desYCurve - odoYPos;\n    double dhCurveError = dhCurveTotal - (sqrt(pow(xCurveError, 2) + pow(yCurveError, 2)));\n    double thetaError = thetaFinal - (acos(1 - (pow(dhCurveError/r, 2))/2)); //for the adjusting theta value (thetaCurrent), r is constant\n    double dMCurveError = dhCurveError*(thetaError*cos(thetaError/2)) / sin(thetaError);\n\n    ///////////////////////////////////////////////////\n    // LINEAR DISTANCE BASED ON VOLTAGE CALCTULATION //\n    ///////////////////////////////////////////////////\n\n    //https://www.vexforum.com/t/what-is-rpm-volt/17339\n    // 1260rpm per volt\n    // (1260rotations / 1min) * (1min / 60sec) = 31 rotations/sec\n    double xVolts = driveXPIDOutput;\n    double yVolts = driveYPIDOutput;\n    double volts = sqrt(pow(xVolts, 2) + pow(yVolts, 2));\n    double distance = volts * 31 * 0.002 * 2*M_PI*encWheelRadius; //Volt * (rps/volt) =rotations/sec, * sec = rotations, * wheelCircumference = distance\n\n    //////////////////////////////////////\n    // CIRCLE INTERSECTION CALCULATIONS //\n    //////////////////////////////////////\n\n    //Use x^2 + (y-r)^2 = r^2, (x-odoX)^2 + (y-odoY)^2 = d^2, set equal to each other to find intersections\n    double d = distance;\n    double b = 2*odoXPos/(2*r - 2*odoYPos); //2 circles to point equation coefficient\n    double c = (pow(d, 2) - pow(odoXPos, 2) - pow(odoYPos, 2))/(2*r - 2*odoYPos); //added constant in 2 circles to point equation\n\n    //x and y movement per instant of the curve motion\n    double xpi = (-(2*b*c - 2*r) + sqrt(pow(2*b*c - 2*b*r, 2) - 4*(pow(b, 2) + 1)*(pow(c, 2) - 2*c*r)))/(2*(pow(b, 2) + 1));\n    //choose + for +/- in quadratic to get movement in positive direction\n    double ypi = b*xpi + c;\n\n    //This outputs a coordinate (xpi, ypi) which is the target for the robot. It, in line with the starting position, creates a small directional vector.\n\n    //////////////////////\n    // PID Conservation //\n    //////////////////////\n\n    //In order to conserve the speed of the PID function, the robot should measure the error as the distance of the robot from the end point along the curve\n    //then take that arclength as vector and direct that in a straight line through the point.\n    //This should create a new target point for the robot at the end of that vector.\n\n    //To get that new point, find the angle between the current point and the horizontal.\n    double lambda = atan(ypi/xpi);\n    //Then, use the angle with sin cos to find the target point.\n    //This should output a new TARGET POINT (xpiTarget, ypiTarget)\n    double xpiTarget = dMCurveError*cos(lambda);\n    double ypiTarget = dMCurveError*sin(lambda);\n\n    //Input Adjustment\n    x = xpiTarget;\n    y = ypiTarget;\n}\n\nvoid turnDrive(double dx, double dy, double phiTotal){\n    double dhtotal = sqrt(pow(dx, 2) + pow(dy, 2));\n    \n    ////////////////////////////////////////////////\n    // TURN DISTANCE BASED ON VOLTAGE CALCULATION //\n    ////////////////////////////////////////////////\n    \n    double turnVolts = turnPIDOutput;\n    double turnDist = turnVolts * 31 * 0.002 * 2*M_PI*r*encWheelRadius;\n\n    double driveTrainRadius = 10.25; //half the distance between the wheels diagonally\n\n    double phiInstant = turnDist/driveTrainRadius; //gives dphi for the .02 second interval\n\n    /////////////////////////////\n    // Instant Movement Target //\n    /////////////////////////////\n\n    double dxtotal = -1*dhtotal*cos(phiInstant);\n    double dytotal = dhtotal*sin(phiInstant);\n\n    x = dxtotal;\n    y = dytotal;    \n}\n\n//////////////////\n// Drive Inputs //\n//////////////////\n\nvoid drive(double xFinal, double yFinal, double phiFinal){\n    //inputs\n    desiredXValue = xFinal;\n    desiredYValue = yFinal;\n    desiredTurnValue = phiFinal;\n}\n\nvoid go(double xFinal, double yFinal, double thetaFinal, double phiFinal){\n    //repeats until it gets there\n    while(((errorX) > .1) || ((errorY) > .1) || ((errorTurn) > (M_PI/90))){\n        x = xFinal;\n        y = yFinal;\n        theta = thetaFinal;\n        phi = phiFinal;\n\n        if(phiFinal - odoAng != 0){\n            turnDrive(x, y, phi);\n        }\n\n        if(thetaFinal != 0){\n            curveDrive(x, y, theta);\n        }\n\n        if(phiFinal != 0){\n            acp(x, y, phi);\n        }\n\n        drive(x, y, phi);\n\n        vex::task::sleep(20);\n    }\n}\n\n/*---------------------------*/\n/*                           */\n/*    PERIOD: Autonomous     */\n/*                           */\n/*---------------------------*/\n\n//auton codes for color/side\nvoid blue1(){}\n\nvoid blue2(){}\n\nvoid red1(){}\n\nvoid red2(){}\n\n//auton chooser (called by int main())\nvoid autonomous(void){\n    enableDrivePIDODO = true;\n    vex::task irishRobot(drivePIDODO);\n    if(autonSwitch.angle(degrees)<=61){blue1();}\n    else if(autonSwitch.angle(degrees)<=122){blue2();}\n    else if(autonSwitch.angle(degrees)<=183){red1();}\n    else{red2();}\n\n}\n\n/*----------------------------*/\n/*                            */\n/*    PERIOD: User Control    */\n/*                            */\n/*----------------------------*/\n\nvoid usercontrol(void){\n    enableDrivePIDODO = false;\n}\n\nint main() {\n    pre_auton();\n    autonomous();\n    usercontrol();\n    vex::task::sleep(20);\n}\n\n/*---------------*/\n/*               */\n/*    Credits    */\n/*               */\n/*---------------*/\n\n/////////////\n// Sources //\n/////////////\n\n\n////////////////\n// References //\n////////////////\n\n// { Michael Oltman } - Multi-threading","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"leftDrive","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"rightDrive","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1,2],"name":"leftEncoder","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3,4],"name":"rightEncoder","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22},{"port":[5,6],"name":"centerEncoder","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7],"name":"autonSwitch","customName":true,"deviceType":"Potentiometer","deviceClass":"pot","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3],"name":"hDrive","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[4],"name":"LeftLift","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[5],"name":"RightLift","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[6],"name":"Claw","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[7],"name":"Mogo","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[8],"name":"Intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20211210.18.00.00","appVersion":"2.3.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}